import discord
from discord.ext import commands
from gtts import gTTS
import io
import os
import asyncio
import time
import random
import wavelink
from wavelink.tracks import Playable
from typing import Optional, Union
# Remove spotify extension import as it seems to be missing
import datetime
import re
import math
from urllib.parse import urlparse
from .config import Config
from .database import (
    add_rate_limit_entry, 
    is_rate_limited, 
    store_audio_tts, 
    get_latest_audio_tts, 
    get_audio_tts_by_id,
    cleanup_old_audio_tts
)

class MusicPlayer(wavelink.Player):
    """Custom player class with queue functionality"""
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.queue = asyncio.Queue()
        self.now_playing = None
        self.is_playing = False
        self.loop = False
        
    async def play_next(self):
        """Play the next track in queue"""
        if self.loop and self.now_playing:
            await self.play(self.now_playing)
            return

        # Check if queue is empty
        if self.queue.empty():
            self.now_playing = None
            return
        
        # Get next track and play it
        track = await self.queue.get()
        self.now_playing = track
        
        # Play using wavelink
        await self.play(track)
    
    async def add_tracks(self, ctx, tracks):
        """Add tracks to the queue with user feedback"""
        if not tracks:
            await ctx.send("**WALA AKONG NAKITANG KANTA!** Try mo nga ulit.", delete_after=15)
            return
        
        # Single track received
        if isinstance(tracks, Playable):
            await self.queue.put(tracks)
            await ctx.send(f"**ADDED TO QUEUE:** {tracks.title}", delete_after=15)
            
        # Multiple tracks - could be playlist
        elif hasattr(tracks, '__iter__'):
            if len(tracks) == 1:
                track = tracks[0]
                await self.queue.put(track)
                await ctx.send(f"**ADDED TO QUEUE:** {track.title}", delete_after=15)
            else:
                # Handling a playlist
                await ctx.send(f"**ADDED PLAYLIST:** {len(tracks)} tracks", delete_after=15)
                for track in tracks:
                    await self.queue.put(track)
        
        # Start playing if not already playing
        if not self.is_playing:
            await self.play_next()
            
class AudioCog(commands.Cog):
    """Cog for handling voice channel interactions and TTS using Wavelink/Lavalink"""

    def __init__(self, bot):
        self.bot = bot
        self.temp_dir = "temp_audio"
        # Create temp directory if it doesn't exist
        if not os.path.exists(self.temp_dir):
            os.makedirs(self.temp_dir)
        
        # Track nodes and players
        self.wavelink_connected = False
        self.node = None
        self.players = {}

    async def cog_load(self):
        """Initialize wavelink and connect to nodes"""
        print("Initializing Wavelink...")
        
        # Setup Wavelink nodes
        try:
            # Get local Lavalink node
            self.node = wavelink.Node(
                uri='http://localhost:2333',
                password='youshallnotpass'
            )
            await wavelink.NodePool.connect(client=self.bot, nodes=[self.node])
            self.wavelink_connected = True
            print("‚úÖ Connected to Lavalink node!")
            
            # Setup track end event handling
            self.bot.add_listener(self.on_wavelink_track_end, "on_wavelink_track_end")
            
        except Exception as e:
            print(f"‚ùå ERROR: Could not connect to Lavalink node: {e}")
            self.wavelink_connected = False
        
        print("‚úÖ Audio Cog loaded")
        
    async def on_wavelink_track_end(self, player: wavelink.Player, track: Playable, reason):
        """Called when a track finishes playing"""
        # Handle only our MusicPlayer instances
        if not isinstance(player, MusicPlayer):
            return
            
        player.is_playing = False
        
        # Play next track in queue if there is one
        if not player.queue.empty():
            await player.play_next()
        else:
            player.now_playing = None

    async def cog_unload(self):
        """Clean up when cog is unloaded"""
        # Disconnect all players gracefully
        for player in wavelink.NodePool.get_node().players.values():
            try:
                await player.disconnect()
            except:
                pass

    @commands.Cog.listener()
    async def on_voice_state_update(self, member, before, after):
        """Track voice channel changes"""
        # Don't take action on bot movement
        if member.id == self.bot.user.id:
            return
        
        # Auto-join logic (when user joins an empty channel)
        if before.channel is None and after.channel is not None:
            # Count human members in the channel
            members_in_channel = len([m for m in after.channel.members if not m.bot])
            
            # If just one human (the person who joined)
            if members_in_channel == 1:
                # Check if we're already in a voice channel in this guild
                try:
                    player = wavelink.NodePool.get_node().get_player(member.guild.id)
                    if player.is_connected():
                        return  # Already connected
                except:
                    # Not connected, so we can join
                    try:
                        channel = after.channel
                        await channel.connect(cls=wavelink.Player)
                        print(f"Auto-joined voice channel: {after.channel.name}")
                    except Exception as e:
                        print(f"Error auto-joining channel: {e}")

    @commands.command(name="joinvc")
    async def joinvc(self, ctx):
        """Join a voice channel using Wavelink"""
        if not ctx.author.voice:
            return await ctx.send("**TANGA!** WALA KA SA VOICE CHANNEL!")
        
        # Get the user's channel
        channel = ctx.author.voice.channel
        
        try:
            # Check if already in a voice channel
            try:
                player = wavelink.NodePool.get_node().get_player(ctx.guild.id)
                if player and player.channel == channel:
                    return await ctx.send("**BOBO!** NASA VOICE CHANNEL MO NA AKO!")
                elif player:
                    await player.disconnect()
            except:
                pass
                
            # Connect to the user's channel
            player = await channel.connect(cls=wavelink.Player)
            await ctx.send(f"**SIGE!** PAPASOK NA KO SA {channel.name}!")
            
        except Exception as e:
            await ctx.send(f"**ERROR:** {str(e)}")
            print(f"Error joining voice channel: {e}")
    
    @commands.command(name="leavevc")
    async def leavevc(self, ctx):
        """Leave the voice channel"""
        try:
            player = wavelink.NodePool.get_node().get_player(ctx.guild.id)
            if not player or not player.is_connected():
                return await ctx.send("**TANGA!** WALA AKO SA VOICE CHANNEL!")
            
            await player.disconnect()
            await ctx.send("**AYOS!** UMALIS NA KO!")
            
        except Exception as e:
            await ctx.send(f"**ERROR:** {str(e)}")
            print(f"Error leaving voice channel: {e}")
    
    @commands.command(name="vc")
    async def vc(self, ctx, *, message: str):
        """Text-to-speech using Wavelink/Lavalink"""
        # Check if user is in a voice channel
        if not ctx.author.voice:
            return await ctx.send("**TANGA!** WALA KA SA VOICE CHANNEL!")
        
        # Check if wavelink is working
        if not self.wavelink_connected:
            return await ctx.send("**ERROR:** Wavelink/Lavalink is not connected!")
        
        # Check rate limiting
        if is_rate_limited(ctx.author.id):
            return await ctx.send(f"**TEKA LANG {ctx.author.mention}!** Ang bilis mo mag-type! Hinay-hinay lang!")
        
        add_rate_limit_entry(ctx.author.id)
        
        # Send processing message
        processing_msg = await ctx.send("**SANDALI LANG!** Ginagawa ko pa yung audio...")
        
        try:
            # Generate TTS
            tts = gTTS(text=message, lang='tl', slow=False)
            
            # Create a unique filename for this TTS request
            filename = f"temp_audio/tts_{ctx.message.id}.mp3"
            
            # Save to file
            tts.save(filename)
            
            # Verify file exists
            if not os.path.exists(filename) or os.path.getsize(filename) == 0:
                raise Exception("Failed to generate audio file")
            
            # Store in database
            with open(filename, "rb") as f:
                audio_data = f.read()
                audio_id = store_audio_tts(ctx.author.id, message, audio_data)
            
            # Get or create the player
            try:
                player = wavelink.NodePool.get_node().get_player(ctx.guild.id)
                if not player or not player.is_connected():
                    player = await ctx.author.voice.channel.connect(cls=wavelink.Player)
            except Exception as connect_error:
                raise Exception(f"Voice connection error: {connect_error}")
            
            # Create a playable track from local file
            track = await wavelink.LocalTrack.search(filename)
            
            # Play the track
            await player.play(track)
            
            # Delete the processing message
            await processing_msg.delete()
            
            # Send success message
            await ctx.send(f"üîä **SPEAKING:** {message}", delete_after=10)
            
            # Clean up the file after playing
            try:
                os.remove(filename)
            except Exception as e:
                print(f"Error removing file: {e}")
            
            # Clean up old database entries
            cleanup_old_audio_tts(keep_count=20)
            
        except Exception as e:
            print(f"‚ö†Ô∏è TTS ERROR: {e}")
            
            # Try to delete processing message
            try:
                await processing_msg.delete()
            except:
                pass
            
            # Send error message
            await ctx.send(f"**ERROR:** {str(e)}", delete_after=10)
    
    @commands.command(name="replay")
    async def replay(self, ctx):
        """Replay last TTS message from database using Wavelink"""
        # Check if user is in a voice channel
        if not ctx.author.voice:
            return await ctx.send("**TANGA!** WALA KA SA VOICE CHANNEL!")
        
        # Check if wavelink is working
        if not self.wavelink_connected:
            return await ctx.send("**ERROR:** Wavelink/Lavalink is not connected!")
        
        # Send processing message
        processing_msg = await ctx.send("**SANDALI LANG!** Hinahanap ko yung audio...")
        
        try:
            # Get latest audio from database
            latest_audio = get_latest_audio_tts()
            
            if not latest_audio or not latest_audio[1]:
                await processing_msg.delete()
                return await ctx.send("**WALA PA AKONG NASABI!** Wala pang audio sa database!")
            
            audio_id = latest_audio[0]
            audio_data = latest_audio[1]
            
            # Save to temporary file
            filename = f"temp_audio/replay_{ctx.message.id}.mp3"
            with open(filename, "wb") as f:
                f.write(audio_data)
            
            # Get or create the player
            try:
                player = wavelink.NodePool.get_node().get_player(ctx.guild.id)
                if not player or not player.is_connected():
                    player = await ctx.author.voice.channel.connect(cls=wavelink.Player)
            except Exception as connect_error:
                raise Exception(f"Voice connection error: {connect_error}")
            
            # Create a playable track from local file
            track = await wavelink.LocalTrack.search(filename)
            
            # Play the track
            await player.play(track)
            
            # Delete the processing message
            await processing_msg.delete()
            
            # Send success message
            await ctx.send(f"üîä **REPLAY:** Audio ID: {audio_id}", delete_after=10)
            
            # Clean up the file after playing
            try:
                os.remove(filename)
            except Exception as e:
                print(f"Error removing file: {e}")
            
        except Exception as e:
            print(f"‚ö†Ô∏è REPLAY ERROR: {e}")
            
            # Try to delete processing message
            try:
                await processing_msg.delete()
            except:
                pass
            
            # Send error message
            await ctx.send(f"**ERROR:** {str(e)}", delete_after=10)
            
    @commands.command(name="play")
    async def play(self, ctx, *, query: str):
        """Play a song or add it to the queue (g!play <song name or URL>)"""
        # Check if user is in a voice channel
        if not ctx.author.voice:
            return await ctx.send("**TANGA!** WALA KA SA VOICE CHANNEL!")
        
        # Check if wavelink is working
        if not self.wavelink_connected:
            return await ctx.send("**ERROR:** Wavelink/Lavalink is not connected!")
        
        # Send searching message
        search_msg = await ctx.send(f"**SANDALI LANG!** Hinahanap ko pa: `{query}`...")
        
        try:
            # Get or create player for this guild
            player = wavelink.NodePool.get_node().get_player(ctx.guild.id)
            
            # If player doesn't exist or isn't connected, create a new MusicPlayer
            if not player or not player.is_connected():
                player = await ctx.author.voice.channel.connect(cls=MusicPlayer)
                # Add it to our players dictionary
                self.players[ctx.guild.id] = player
            elif not isinstance(player, MusicPlayer):
                # If we have a regular player but not a MusicPlayer, disconnect and make a MusicPlayer
                await player.disconnect()
                player = await ctx.author.voice.channel.connect(cls=MusicPlayer)
                self.players[ctx.guild.id] = player
            
            # Process the search query - determine if URL or search term
            is_url = bool(re.match(r'https?://', query))
            
            if is_url:
                # Direct URL to a song/playlist
                tracks = await wavelink.NodePool.get_node().get_tracks(query=query)
            else:
                # Search for the song on YouTube
                tracks = await wavelink.YouTubeTrack.search(query=query)
            
            # Delete the searching message
            await search_msg.delete()
            
            # Add the track(s) to the queue
            await player.add_tracks(ctx, tracks)
            
            # Mark as playing to avoid auto-play confusion
            player.is_playing = True
            
        except Exception as e:
            print(f"‚ö†Ô∏è PLAY ERROR: {e}")
            
            # Try to delete search message
            try:
                await search_msg.delete()
            except:
                pass
            
            # Send error message
            await ctx.send(f"**ERROR:** {str(e)}", delete_after=10)

    @commands.command(name="skip")
    async def skip(self, ctx):
        """Skip the current song"""
        player = wavelink.NodePool.get_node().get_player(ctx.guild.id)
        
        if not player or not player.is_connected():
            return await ctx.send("**TANGA!** WALA AKONG TUMUTUGTOG NA KANTA!")
        
        if not isinstance(player, MusicPlayer):
            return await ctx.send("**BOBO!** HINDI MUSIC PLAYER YAN!")
        
        # Skip current song
        await player.stop()
        
        await ctx.send("**SKIPPED!** Ayaw mo pala yung kanta eh!", delete_after=10)

    @commands.command(name="queue")
    async def queue(self, ctx):
        """Show the current song queue"""
        player = wavelink.NodePool.get_node().get_player(ctx.guild.id)
        
        if not player or not player.is_connected():
            return await ctx.send("**TANGA!** WALA AKONG TUMUTUGTOG NA KANTA!")
        
        if not isinstance(player, MusicPlayer):
            return await ctx.send("**BOBO!** HINDI MUSIC PLAYER YAN!")
        
        if player.queue.empty() and not player.now_playing:
            return await ctx.send("**GAGO!** WALANG KANTA SA QUEUE!", delete_after=10)
        
        # Create an embed for the queue
        embed = discord.Embed(
            title="**MUSIC QUEUE**",
            description="**NOW PLAYING:**\n" + (f"üîä **{player.now_playing.title}**" if player.now_playing else "Nothing"),
            color=Config.EMBED_COLOR_PRIMARY
        )
        
        # Get a snapshot of the queue - we access internal items, but this is read-only
        upcoming = []
        
        # This is a way to get a read-only copy of queue items
        queue_items = []
        # We'll create a temporary queue and then restore it
        temp_queue = asyncio.Queue()
        
        # Safely get all items
        while not player.queue.empty():
            item = await player.queue.get()
            queue_items.append(item)
            await temp_queue.put(item)
        
        # Restore player's queue
        player.queue = temp_queue
        
        # Build display list from our safe copy
        position = 1
        for track in queue_items[:10]:  # Only show first 10 songs
            upcoming.append(f"`{position}.` {track.title}")
            position += 1
                
        if upcoming:
            embed.add_field(
                name="**NEXT UP:**",
                value="\n".join(upcoming),
                inline=False
            )
            
            if len(queue_items) > 10:
                embed.set_footer(text=f"And {len(queue_items) - 10} more songs in queue!")
        
        await ctx.send(embed=embed)

    @commands.command(name="pause")
    async def pause(self, ctx):
        """Pause the current song"""
        player = wavelink.NodePool.get_node().get_player(ctx.guild.id)
        
        if not player or not player.is_connected():
            return await ctx.send("**TANGA!** WALA AKONG TUMUTUGTOG NA KANTA!")
        
        if not player.is_playing():
            return await ctx.send("**GAGO!** PAUSED NA NGA EH!", delete_after=10)
        
        await player.pause()
        await ctx.send("**PAUSED!** Bakit mo pinahinto?", delete_after=10)

    @commands.command(name="resume")
    async def resume(self, ctx):
        """Resume the current song"""
        player = wavelink.NodePool.get_node().get_player(ctx.guild.id)
        
        if not player or not player.is_connected():
            return await ctx.send("**TANGA!** WALA AKONG TUMUTUGTOG NA KANTA!")
        
        if player.is_playing():
            return await ctx.send("**GAGO!** TUMUTUGTOG NA NGA EH!", delete_after=10)
        
        await player.resume()
        await ctx.send("**RESUMED!** Ayan na ulit tumutugtog!", delete_after=10)

    @commands.command(name="stop")
    async def stop(self, ctx):
        """Stop playing and clear the queue"""
        player = wavelink.NodePool.get_node().get_player(ctx.guild.id)
        
        if not player or not player.is_connected():
            return await ctx.send("**TANGA!** WALA AKONG TUMUTUGTOG NA KANTA!")
        
        if isinstance(player, MusicPlayer):
            # Clear the queue
            player.queue = asyncio.Queue()
        
        # Stop playback
        await player.stop()
        
        await ctx.send("**STOPPED!** Inalis ko na lahat ng kanta!", delete_after=10)

    @commands.command(name="nowplaying", aliases=["np"])
    async def nowplaying(self, ctx):
        """Show information about the current song"""
        player = wavelink.NodePool.get_node().get_player(ctx.guild.id)
        
        if not player or not player.is_connected() or not player.is_playing():
            return await ctx.send("**TANGA!** WALA AKONG TUMUTUGTOG NA KANTA!")
        
        if not isinstance(player, MusicPlayer) or not player.now_playing:
            return await ctx.send("**WALA NGANG TUMUTUGTOG SABI EH!**", delete_after=10)
        
        track = player.now_playing
        
        # Create a progress bar
        position = player.position
        duration = track.duration
        
        if position and duration:
            # Calculate progress as a percentage
            percent = min(position / duration, 1.0)
            bar_length = 20
            filled_length = round(bar_length * percent)
            
            # Create the bar ‚ñì‚ñì‚ñì‚ñì‚ñì‚ñë‚ñë‚ñë‚ñë‚ñë
            bar = '‚ñì' * filled_length + '‚ñë' * (bar_length - filled_length)
            
            # Format time as MM:SS
            def format_time(ms):
                seconds = int(ms / 1000) % 60
                minutes = int(ms / (1000 * 60))
                return f"{minutes:02d}:{seconds:02d}"
            
            progress_text = f"{format_time(position)} {bar} {format_time(duration)}"
        else:
            progress_text = "Progress unavailable"
        
        # Create embed
        embed = discord.Embed(
            title="**NOW PLAYING:**",
            description=f"**{track.title}**",
            color=Config.EMBED_COLOR_PRIMARY
        )
        
        # Add track details
        embed.add_field(
            name="Progress:",
            value=progress_text,
            inline=False
        )
        
        if hasattr(track, 'author'):
            embed.add_field(
                name="Artist:",
                value=track.author,
                inline=True
            )
        
        # Add the requester if we start tracking that
        
        await ctx.send(embed=embed)

def setup(bot):
    """Add cog to bot"""
    bot.add_cog(AudioCog(bot))